#!/bin/sh
#
# Traffic logging tool for OpenWRT-based routers
#
# Created by Emmanuel Brucy (e.brucy AT qut.edu.au)
#
# Based on work from Fredrik Erlandsson (erlis AT linux.nu)
# Based on traff_graph script by twist - http://wiki.openwrt.org/RrdTrafficWatch
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#set -x
chains='INPUT OUTPUT FORWARD'
DEBUG=
tun=tun0

lock()
{
    while [ -f /tmp/wrtbwmon.lock ]; do
	if [ ! -d /proc/$(cat /tmp/wrtbwmon.lock) ]; then
	    echo "WARNING: Lockfile detected but process $(cat /tmp/wrtbwmon.lock) does not exist !"
	    rm -f /tmp/wrtbwmon.lock
	fi
	sleep 1
    done
    echo $$ > /tmp/wrtbwmon.lock
}

unlock()
{
    rm -f /tmp/wrtbwmon.lock
}

case $1 in

    "setup" )
	for chain in $chains; do
	    #Create the RRDIPT_$chain chain (it doesn't matter if it already exists).
	    iptables -N RRDIPT_$chain 2> /dev/null

	    #Add the RRDIPT_$chain CHAIN to the $chain chain (if non existing).
	    iptables -L $chain --line-numbers -n | grep "RRDIPT_$chain" > /dev/null
	    if [ $? -ne 0 ]; then
		iptables -L $chain -n | grep "RRDIPT_$chain" > /dev/null
		if [ $? -eq 0 ]; then
		    [ -n "$DEBUG" ] && echo "DEBUG: iptables chain misplaced, recreating it..."
		    iptables -D $chain -j RRDIPT_$chain
		fi
		iptables -I $chain -j RRDIPT_$chain
	    fi
	    #For each host in the ARP table
            cat /proc/net/arp | tail -n +2 | \
		while read IP TYPE FLAGS MAC MASK IFACE
		do
		    #Add iptable rules (if non existing).
		    iptables -nL RRDIPT_$chain | grep "${IP} " > /dev/null
		    if [ $? -ne 0 ]; then
			if [ "$chain" = "OUTPUT" -o "$chain" = "FORWARD" ]; then
			    iptables -I RRDIPT_$chain -d ${IP} -j RETURN
			fi
			if [ "$chain" = "INPUT" -o "$chain" = "FORWARD" ]; then
			    iptables -I RRDIPT_$chain -s ${IP} -j RETURN
			fi
		    fi
		done

	    #!@todo automate this;
	    # can detect gateway IPs: route -n | grep '^[0-9]' | awk '{print $2}' | sort | uniq | grep -v 0.0.0.0
	    if [ -n "$tun" ]; then
		if [ "$chain" = "OUTPUT" ]; then
		    iptables -A RRDIPT_$chain -o $tun -j RETURN
		elif [ "$chain" = "INPUT" ]; then
		    iptables -A RRDIPT_$chain -i $tun -j RETURN
		fi
	    fi
	done # for all chains
	
	;;
    
    "update" )
	[ -z "$2" ] && echo "ERROR: Missing argument 2" && exit 1	
	[ ! -f "$2" ] && touch "$2"
	[ ! -w "$2" ] && echo "ERROR: $2 not writable" && exit 1

	lock

	#Read and reset counters
	for chain in $chains; do
	    iptables -L RRDIPT_$chain -vnxZ > /tmp/traffic_${chain}_$$.tmp
	done

	egrep -v "0x0|^IP" /proc/net/arp  | \
	    while read IP TYPE FLAGS MAC MASK IFACE
	    do
		IN=0
		OUT=0
		#Add new data to the graph.
		for chain in $chains; do
		    grep ${IP} /tmp/traffic_${chain}_$$.tmp > /tmp/${IP}_${chain}_$$.tmp
		    while read PKTS BYTES TARGET PROT OPT IFIN IFOUT SRC DST
		    do
			[ "$chain" = "OUTPUT" -o "$chain" = "FORWARD" ] && [ "${DST}" = "${IP}" ] && IN=$((IN + BYTES))
			[ "$chain" = "INPUT" -o "$chain" = "FORWARD" ] && [ "${SRC}" = "${IP}" ] && OUT=$((OUT + BYTES))
		    done < /tmp/${IP}_${chain}_$$.tmp
		    rm -f /tmp/${IP}_${chain}_$$.tmp
		done
		[[ $IN -gt 0 ]] || [[ $OUT -gt 0 ]] || continue
		
		if [ "${IN}" -gt 0 -o "${OUT}" -gt 0 ];  then
		    [ -n "$DEBUG" ] && echo "DEBUG: New traffic for ${MAC} since last update: ${IN}:${OUT}"
		    
		    LINE=$(grep ${MAC} $2)
		    if [ -z "${LINE}" ]; then
			[ -n "$DEBUG" ] && echo "DEBUG: ${MAC} is a new host !"
			PEAKUSAGE_IN=0
			PEAKUSAGE_OUT=0
			OFFPEAKUSAGE_IN=0
			OFFPEAKUSAGE_OUT=0
		    else
			echo $LINE | cut -s -d, -f2-5 | tr ',' ' ' > "/tmp/${MAC}_$$.tmp"
			read PEAKUSAGE_IN PEAKUSAGE_OUT OFFPEAKUSAGE_IN OFFPEAKUSAGE_OUT < "/tmp/${MAC}_$$.tmp"
		    fi
		    echo $PEAKUSAGE_IN $PEAKUSAGE_OUT $OFFPEAKUSAGE_IN $OFFPEAKUSAGE_OUT
		    
		    if [ "${3}" = "offpeak" ]; then
			echo $LINE | cut -f4,5 -s -d, | tr ',' ' ' > "/tmp/${MAC}_$$.tmp"
			read OFFPEAKUSAGE_IN OFFPEAKUSAGE_OUT < "/tmp/${MAC}_$$.tmp"
			OFFPEAKUSAGE_IN=$((OFFPEAKUSAGE_IN + IN))
			OFFPEAKUSAGE_OUT=$((OFFPEAKUSAGE_OUT + OUT))
		    else
			echo $LINE | cut -f2,3 -s -d, | tr ',' ' ' > "/tmp/${MAC}_$$.tmp"
			read PEAKUSAGE_IN PEAKUSAGE_OUT < "/tmp/${MAC}_$$.tmp"
			PEAKUSAGE_IN=$((PEAKUSAGE_IN + IN))
			PEAKUSAGE_OUT=$((PEAKUSAGE_OUT + OUT))
		    fi

		    rm -f "/tmp/${MAC}_$$.tmp"
		    
		    grep -v "${MAC}" $2 > /tmp/db_$$.tmp
		    mv /tmp/db_$$.tmp $2
		    echo ${MAC},${PEAKUSAGE_IN},${PEAKUSAGE_OUT},${OFFPEAKUSAGE_IN},${OFFPEAKUSAGE_OUT},$(date "+%d-%m-%Y %H:%M:%S") >> $2
		fi
	    done

	#Free some memory
	rm -f /tmp/*_$$.tmp
	unlock
	;;
    
    "publish" )

	[ -z "$2" ] && echo "ERROR: Missing argument 2" && exit 1
	[ -z "$3" ] && echo "ERROR: Missing argument 3" && exit 1
	
	USERSFILE="/etc/dnsmasq.conf"
	[ -f "$USERSFILE" ] || USERSFILE="/tmp/dnsmasq.conf"
	[ -z "$4" ] || USERSFILE=${4}
	[ -f "$USERSFILE" ] || USERSFILE="/dev/null"

	# first do some number crunching - rewrite the database so that it is sorted
	lock
	touch /tmp/sorted_$$.tmp
	cat $2 | while IFS=, read MAC PEAKUSAGE_IN PEAKUSAGE_OUT OFFPEAKUSAGE_IN OFFPEAKUSAGE_OUT LASTSEEN
		   do
		       echo ${PEAKUSAGE_IN},${PEAKUSAGE_OUT},${OFFPEAKUSAGE_IN},${OFFPEAKUSAGE_OUT},${MAC},${LASTSEEN} >> /tmp/sorted_$$.tmp
		   done
	unlock

        # create HTML page
        echo "<html><head><title>Traffic</title><script type=\"text/javascript\">" > ${3}
        echo "function getSize(size) {" >> ${3}
        echo "var prefix=new Array(\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\"); var base=1000;" >> ${3}
        echo "var pos=0; while (size>base) { size/=base; pos++; } if (pos > 2) precision=1000; else precision = 1;" >> ${3}
        echo "return (Math.round(size*precision)/precision)+' '+prefix[pos];}" >> ${3}
        echo "</script></head><body><h1>Total Usage :</h1>" >> ${3}
        echo "<table border="1"><tr bgcolor=silver><th>User</th><th>Peak download</th><th>Peak upload</th><th>Offpeak download</th><th>Offpeak upload</th><th>Last seen</th></tr>" >> ${3}
        echo "<script type=\"text/javascript\">" >> ${3}

        echo "var values = new Array(" >> ${3}
        sort -n /tmp/sorted_$$.tmp | while IFS=, read PEAKUSAGE_IN PEAKUSAGE_OUT OFFPEAKUSAGE_IN OFFPEAKUSAGE_OUT MAC LASTSEEN
				     do
					 echo "new Array(" >> ${3}
					 USER=$(grep "${MAC}" "${USERSFILE}" | cut -f2 -s -d, )
					 [ -z "$USER" ] && USER=${MAC}
					 echo "\"${USER}\",${PEAKUSAGE_IN}000,${PEAKUSAGE_OUT}000,${OFFPEAKUSAGE_IN}000,${OFFPEAKUSAGE_OUT}000,\"${LASTSEEN}\")," >> ${3}
				     done
        echo "0);" >> ${3}

        echo "for (i=0; i < values.length-1; i++) {document.write(\"<tr><td>\");" >> ${3}
        echo "document.write(values[i][0]);document.write(\"</td>\");" >> ${3}
	for j in 1 2 3 4; do
            echo "document.write(\"<td>\");document.write(getSize(values[i][$j]));document.write(\"</td>\");" >> ${3}
	done
        echo "document.write(\"<td>\");document.write(values[i][5]);document.write(\"</td>\");" >> ${3}
        echo "document.write(\"</tr>\");" >> ${3}
        echo "}</script></table>" >> ${3}
        echo "<br /><small>This page was generated on `date`</small>" 2>&1 >> ${3}
        echo "</body></html>" >> ${3}

        #Free some memory
        rm -f /tmp/*_$$.tmp
        ;;

    "remove" )
	for chain in $chains; do
	    iptables -D $chain -j RRDIPT_$chain 2> /dev/null
	    true
	    a=$?
	    while [[ $a -eq 0 ]]; do
		iptables -D RRDIPT_$chain 1 2> /dev/null
		a=$?
	    done
	    iptables -X RRDIPT_$chain 2> /dev/null
	done
	;;
    
    *)
	echo "Usage: $0 {setup|update|publish|remove} [options...]"
	echo "Options: "
	echo "   $0 setup"
	echo "   $0 update database_file [offpeak]"
	echo "   $0 publish database_file path_of_html_report [user_file]"
	echo "Examples: "
	echo "   $0 setup"
	echo "   $0 update /tmp/usage.db offpeak"
	echo "   $0 publish /tmp/usage.db /www/user/usage.htm /jffs/users.txt"
	echo "   $0 remove"
	echo "Note: [user_file] is an optional file to match users with their MAC address"
	echo "       Its format is: 00:MA:CA:DD:RE:SS,username , with one entry per line"
	exit
	;;
esac
